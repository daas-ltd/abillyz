import{countColumn as e,EditorSelection as t,Prec as r,EditorState as n}from"@codemirror/state";import{keymap as o}from"@codemirror/view";import{defineLanguageFacet as l,foldNodeProp as i,indentNodeProp as s,languageDataProp as m,syntaxTree as a,foldService as f,Language as u,LanguageDescription as c,ParseContext as g,indentUnit as d,LanguageSupport as h}from"@codemirror/language";import{CompletionContext as p}from"@codemirror/autocomplete";import{parser as x,GFM as k,Subscript as L,Superscript as w,Emoji as b,MarkdownParser as C,parseCode as A}from"@lezer/markdown";import{html as B,htmlCompletionSource as I}from"@codemirror/lang-html";import{NodeProp as v}from"@lezer/common";const S=l({commentTokens:{block:{open:"\x3c!--",close:"--\x3e"}}});const y=new v;const T=x.configure({props:[i.add((e=>!e.is("Block")||e.is("Document")||isHeading(e)!=null?void 0:(e,t)=>({from:t.doc.lineAt(e.from).to,to:e.to}))),y.add(isHeading),s.add({Document:()=>null}),m.add({Document:S})]});function isHeading(e){let t=/^(?:ATX|Setext)Heading(\d)$/.exec(e.name);return t?+t[1]:void 0}function findSectionEnd(e,t){let r=e;for(;;){let e,n=r.nextSibling;if(!n||(e=isHeading(n.type))!=null&&e<=t)break;r=n}return r.to}const D=f.of(((e,t,r)=>{for(let n=a(e).resolveInner(r,-1);n;n=n.parent){if(n.from<t)break;let e=n.type.prop(y);if(e==null)continue;let o=findSectionEnd(n,e);if(o>r)return{from:r,to:o}}return null}));function mkLang(e){return new u(S,e,[D],"markdown")}const M=mkLang(T);const z=T.configure([k,L,w,b,{props:[i.add({Table:(e,t)=>({from:t.doc.lineAt(e.from).to,to:e.to})})]}]);const E=mkLang(z);function getCodeParser(e,t){return r=>{if(r&&e){let t=null;r=/\S*/.exec(r)[0];t=typeof e=="function"?e(r):c.matchLanguageName(e,r,true);if(t instanceof c)return t.support?t.support.language.parser:g.getSkippingParser(t.load());if(t)return t.parser}return t?t.parser:null}}class Context{constructor(e,t,r,n,o,l,i){this.node=e;this.from=t;this.to=r;this.spaceBefore=n;this.spaceAfter=o;this.type=l;this.item=i}blank(e,t=true){let r=this.spaceBefore+(this.node.name=="Blockquote"?">":"");if(e!=null){while(r.length<e)r+=" ";return r}for(let e=this.to-this.from-r.length-this.spaceAfter.length;e>0;e--)r+=" ";return r+(t?this.spaceAfter:"")}marker(e,t){let r=this.node.name=="OrderedList"?String(+itemNumber(this.item,e)[2]+t):"";return this.spaceBefore+r+this.type+this.spaceAfter}}function getContext(e,t){let r=[];for(let t=e;t&&t.name!="Document";t=t.parent)t.name!="ListItem"&&t.name!="Blockquote"&&t.name!="FencedCode"||r.push(t);let n=[];for(let e=r.length-1;e>=0;e--){let o,l=r[e];let i=t.lineAt(l.from),s=l.from-i.from;if(l.name=="FencedCode")n.push(new Context(l,s,s,"","","",null));else if(l.name=="Blockquote"&&(o=/^ *>( ?)/.exec(i.text.slice(s))))n.push(new Context(l,s,s+o[0].length,"",o[1],">",null));else if(l.name=="ListItem"&&l.parent.name=="OrderedList"&&(o=/^( *)\d+([.)])( *)/.exec(i.text.slice(s)))){let e=o[3],t=o[0].length;if(e.length>=4){e=e.slice(0,e.length-4);t-=4}n.push(new Context(l.parent,s,s+t,o[1],e,o[2],l))}else if(l.name=="ListItem"&&l.parent.name=="BulletList"&&(o=/^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(i.text.slice(s)))){let e=o[4],t=o[0].length;if(e.length>4){e=e.slice(0,e.length-4);t-=4}let r=o[2];o[3]&&(r+=o[3].replace(/[xX]/," "));n.push(new Context(l.parent,s,s+t,o[1],e,r,l))}}return n}function itemNumber(e,t){return/^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(e.from,e.from+10))}function renumberList(e,t,r,n=0){for(let o=-1,l=e;;){if(l.name=="ListItem"){let e=itemNumber(l,t);let i=+e[2];if(o>=0){if(i!=o+1)return;r.push({from:l.from+e[1].length,to:l.from+e[0].length,insert:String(o+2+n)})}o=i}let e=l.nextSibling;if(!e)break;l=e}}function normalizeIndent(t,r){let n=/^[ \t]*/.exec(t)[0].length;if(!n||r.facet(d)!="\t")return t;let o=e(t,4,n);let l="";for(let e=o;e>0;)if(e>=4){l+="\t";e-=4}else{l+=" ";e--}return l+t.slice(n)}const insertNewlineContinueMarkup=({state:r,dispatch:n})=>{let o=a(r),{doc:l}=r;let i=null,s=r.changeByRange((n=>{if(!n.empty||!E.isActiveAt(r,n.from))return i={range:n};let s=n.from,m=l.lineAt(s);let a=getContext(o.resolveInner(s,-1),l);while(a.length&&a[a.length-1].from>s-m.from)a.pop();if(!a.length)return i={range:n};let f=a[a.length-1];if(f.to-f.spaceAfter.length>s-m.from)return i={range:n};let u=s>=f.to-f.spaceAfter.length&&!/\S/.test(m.text.slice(f.to));if(f.item&&u){if(f.node.firstChild.to>=s||m.from>0&&!/[^\s>]/.test(l.lineAt(m.from-1).text)){let e=a.length>1?a[a.length-2]:null;let r,n="";if(e&&e.item){r=m.from+e.from;n=e.marker(l,1)}else r=m.from+(e?e.to:0);let o=[{from:r,to:s,insert:n}];f.node.name=="OrderedList"&&renumberList(f.item,l,o,-2);e&&e.node.name=="OrderedList"&&renumberList(e.item,l,o);return{range:t.cursor(r+n.length),changes:o}}{let n="";for(let t=0,r=a.length-2;t<=r;t++)n+=a[t].blank(t<r?e(m.text,4,a[t+1].from)-n.length:null,t<r);n=normalizeIndent(n,r);return{range:t.cursor(s+n.length+1),changes:{from:m.from,insert:n+r.lineBreak}}}}if(f.node.name=="Blockquote"&&u&&m.from){let e=l.lineAt(m.from-1),t=/>\s*$/.exec(e.text);if(t&&t.index==f.from){let o=r.changes([{from:e.from+t.index,to:e.to},{from:m.from+f.from,to:m.to}]);return{range:n.map(o),changes:o}}}let c=[];f.node.name=="OrderedList"&&renumberList(f.item,l,c);let g=f.item&&f.item.from<m.from;let d="";if(!g||/^[\s\d.)\-+*>]*/.exec(m.text)[0].length>=f.to)for(let t=0,r=a.length-1;t<=r;t++)d+=t!=r||g?a[t].blank(t<r?e(m.text,4,a[t+1].from)-d.length:null):a[t].marker(l,1);let h=s;while(h>m.from&&/\s/.test(m.text.charAt(h-m.from-1)))h--;d=normalizeIndent(d,r);c.push({from:h,to:s,insert:r.lineBreak+d});return{range:t.cursor(h+d.length+1),changes:c}}));if(i)return false;n(r.update(s,{scrollIntoView:true,userEvent:"input"}));return true};function isMark(e){return e.name=="QuoteMark"||e.name=="ListMark"}function contextNodeForDelete(e,t){let r=e.resolveInner(t,-1),n=t;if(isMark(r)){n=r.from;r=r.parent}for(let e;e=r.childBefore(n);)if(isMark(e))n=e.from;else{if(e.name!="OrderedList"&&e.name!="BulletList")break;r=e.lastChild;n=r.to}return r}const deleteMarkupBackward=({state:r,dispatch:n})=>{let o=a(r);let l=null,i=r.changeByRange((n=>{let i=n.from,{doc:s}=r;if(n.empty&&E.isActiveAt(r,n.from)){let n=s.lineAt(i);let l=getContext(contextNodeForDelete(o,i),s);if(l.length){let o=l[l.length-1];let s=o.to-o.spaceAfter.length+(o.spaceAfter?1:0);if(i-n.from>s&&!/\S/.test(n.text.slice(s,i-n.from)))return{range:t.cursor(n.from+s),changes:{from:n.from+s,to:i}};if(i-n.from==s&&(!o.item||n.from<=o.item.from||!/\S/.test(n.text.slice(0,o.to)))){let l=n.from+o.from;if(o.item&&o.node.from<o.item.from&&/\S/.test(n.text.slice(o.from,o.to))){let i=o.blank(e(n.text,4,o.to)-e(n.text,4,o.from));l==n.from&&(i=normalizeIndent(i,r));return{range:t.cursor(l+i.length),changes:{from:l,to:n.from+o.to,insert:i}}}if(l<i)return{range:t.cursor(l),changes:{from:l,to:i}}}}}return l={range:n}}));if(l)return false;n(r.update(i,{scrollIntoView:true,userEvent:"delete"}));return true};const F=[{key:"Enter",run:insertNewlineContinueMarkup},{key:"Backspace",run:deleteMarkupBackward}];const H=B({matchClosingTags:false});function markdown(e={}){let{codeLanguages:t,defaultCodeLanguage:n,addKeymap:l=true,base:{parser:i}=M,completeHTMLTags:s=true}=e;if(!(i instanceof C))throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");let m=e.extensions?[e.extensions]:[];let a,f=[H.support];if(n instanceof h){f.push(n.support);a=n.language}else n&&(a=n);let u=t||a?getCodeParser(t,a):void 0;m.push(A({codeParser:u,htmlParser:H.language.parser}));l&&f.push(r.high(o.of(F)));let c=mkLang(i.configure(m));s&&f.push(c.data.of({autocomplete:htmlTagCompletion}));return new h(c,f)}function htmlTagCompletion(e){let{state:t,pos:r}=e,n=/<[:\-\.\w\u00b7-\uffff]*$/.exec(t.sliceDoc(r-25,r));if(!n)return null;let o=a(t).resolveInner(r,-1);while(o&&!o.type.isTop){if(o.name=="CodeBlock"||o.name=="FencedCode"||o.name=="ProcessingInstructionBlock"||o.name=="CommentBlock"||o.name=="Link"||o.name=="Image")return null;o=o.parent}return{from:r-n[0].length,to:r,options:htmlTagCompletions(),validFor:/^<[:\-\.\w\u00b7-\uffff]*$/}}let N=null;function htmlTagCompletions(){if(N)return N;let e=I(new p(n.create({extensions:H}),0,true));return N=e?e.options:[]}export{M as commonmarkLanguage,deleteMarkupBackward,insertNewlineContinueMarkup,markdown,F as markdownKeymap,E as markdownLanguage};

